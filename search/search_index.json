{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to GNU Radio FM application GNU Radio \u2013 A free & open-source toolkit for software radio development. This project demonstrates how to use GNU Radio flow graphs to abstract the signal processing back end from your application frontend to build a modern functional application in no time. The key features of this project are: Spectrum Scanning and FM Detection RDS Decoding Advance Usage of GNU Radio flowgraphs Multiple Streaming Functionality The project directory is: \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 config.json \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u251c\u2500\u2500 img/ \u2502 \u2502 \u2514\u2500\u2500 favicon.ico \u2502 \u2514\u2500\u2500 index.md \u251c\u2500\u2500 downloads \u2502 \u2514\u2500\u2500 2025-08-18_09-01-32.wav \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 Output.wav \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 fm_receiver \u2502 \u251c\u2500\u2500 app.py \u2502 \u251c\u2500\u2500 core/ \u2502 \u2502 \u251c\u2500\u2500 config_manager.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 flowgraphs/ \u2502 \u2502 \u251c\u2500\u2500 fm_receiver.py \u2502 \u2502 \u251c\u2500\u2500 fm_scanner.{grc,py} \u2502 \u2502 \u251c\u2500\u2500 MultipleRecorder.{block.yml,py} \u2502 \u2502 \u251c\u2500\u2500 rds_rx.{grc,py} \u2502 \u2502 \u251c\u2500\u2500 Recorder.grc \u2502 \u2502 \u251c\u2500\u2500 rds_rx_epy_block_0.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 gui/ \u2502 \u2502 \u251c\u2500\u2500 config_dialog.py \u2502 \u2502 \u251c\u2500\u2500 frequency_slider.py \u2502 \u2502 \u251c\u2500\u2500 info_window.py \u2502 \u2502 \u251c\u2500\u2500 main_window.py \u2502 \u2502 \u251c\u2500\u2500 scan_thread.py \u2502 \u2502 \u251c\u2500\u2500 station_button.py \u2502 \u2502 \u251c\u2500\u2500 volume_slider.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 main.py \u2502 \u251c\u2500\u2500 resources/icons/record.png \u2502 \u251c\u2500\u2500 utils/ \u2502 \u2502 \u251c\u2500\u2500 fm_scanner.py \u2502 \u2502 \u251c\u2500\u2500 logging_config.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u2514\u2500\u2500 __pycache__/... \u251c\u2500\u2500 structure.txt \u2514\u2500\u2500 uv.lock Installation Requirements Ensure the following dependencies are installed on your system: GNU Radio gr-rds uv Python 3.10 numpy , matplotlib (automatically handled by uv ) SoapySDR ( sudo apt install soapysdr-module-all ) Running the Project Using uv Install uv by following the installation guide . Make sure GNU Radio and gr-rds are properly installed on your system. Run the FM receiver: uv run src/fm_receiver/main.py Note: Before running, ensure your virtual environment is created with system site packages enabled: python3 -m venv .venv --system-site-packages After running, you should be prompted with the SDR config manager that allows you to choose from attached devices. Home Page In the home page you can listen to different stations, the next and previous buttons lets you jump between adjacent stations. The RDS information is displayed at the button, along with a frequency slider that shows you what frequency you're listening too. You can also record current sessions and scan area for possible FM stations. Station List The station list view allows you to jump arbitrary between stations. It also has a recording functionality for multiple stream recording. Debug View The debug view allows you to control specific elements of the receiver. Especially : RF Gain Filter Cut off-frequency and transition width Tau Pre-emphasis / De-emphasis Networks It also features 5 views of the received signal, including FM Demodulated Signal Waterfall display of demodulated signal L+R stereo display RDS Constellation Audio Display","title":"Home"},{"location":"#welcome-to-gnu-radio-fm-application","text":"GNU Radio \u2013 A free & open-source toolkit for software radio development. This project demonstrates how to use GNU Radio flow graphs to abstract the signal processing back end from your application frontend to build a modern functional application in no time. The key features of this project are: Spectrum Scanning and FM Detection RDS Decoding Advance Usage of GNU Radio flowgraphs Multiple Streaming Functionality The project directory is: \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 config.json \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u251c\u2500\u2500 img/ \u2502 \u2502 \u2514\u2500\u2500 favicon.ico \u2502 \u2514\u2500\u2500 index.md \u251c\u2500\u2500 downloads \u2502 \u2514\u2500\u2500 2025-08-18_09-01-32.wav \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 Output.wav \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 fm_receiver \u2502 \u251c\u2500\u2500 app.py \u2502 \u251c\u2500\u2500 core/ \u2502 \u2502 \u251c\u2500\u2500 config_manager.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 flowgraphs/ \u2502 \u2502 \u251c\u2500\u2500 fm_receiver.py \u2502 \u2502 \u251c\u2500\u2500 fm_scanner.{grc,py} \u2502 \u2502 \u251c\u2500\u2500 MultipleRecorder.{block.yml,py} \u2502 \u2502 \u251c\u2500\u2500 rds_rx.{grc,py} \u2502 \u2502 \u251c\u2500\u2500 Recorder.grc \u2502 \u2502 \u251c\u2500\u2500 rds_rx_epy_block_0.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 gui/ \u2502 \u2502 \u251c\u2500\u2500 config_dialog.py \u2502 \u2502 \u251c\u2500\u2500 frequency_slider.py \u2502 \u2502 \u251c\u2500\u2500 info_window.py \u2502 \u2502 \u251c\u2500\u2500 main_window.py \u2502 \u2502 \u251c\u2500\u2500 scan_thread.py \u2502 \u2502 \u251c\u2500\u2500 station_button.py \u2502 \u2502 \u251c\u2500\u2500 volume_slider.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 main.py \u2502 \u251c\u2500\u2500 resources/icons/record.png \u2502 \u251c\u2500\u2500 utils/ \u2502 \u2502 \u251c\u2500\u2500 fm_scanner.py \u2502 \u2502 \u251c\u2500\u2500 logging_config.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u2514\u2500\u2500 __pycache__/... \u251c\u2500\u2500 structure.txt \u2514\u2500\u2500 uv.lock","title":"Welcome to GNU Radio FM application"},{"location":"#installation","text":"","title":"Installation"},{"location":"#requirements","text":"Ensure the following dependencies are installed on your system: GNU Radio gr-rds uv Python 3.10 numpy , matplotlib (automatically handled by uv ) SoapySDR ( sudo apt install soapysdr-module-all )","title":"Requirements"},{"location":"#running-the-project","text":"","title":"Running the Project"},{"location":"#using-uv","text":"Install uv by following the installation guide . Make sure GNU Radio and gr-rds are properly installed on your system. Run the FM receiver: uv run src/fm_receiver/main.py Note: Before running, ensure your virtual environment is created with system site packages enabled: python3 -m venv .venv --system-site-packages After running, you should be prompted with the SDR config manager that allows you to choose from attached devices.","title":"Using uv"},{"location":"#home-page","text":"In the home page you can listen to different stations, the next and previous buttons lets you jump between adjacent stations. The RDS information is displayed at the button, along with a frequency slider that shows you what frequency you're listening too. You can also record current sessions and scan area for possible FM stations.","title":"Home Page"},{"location":"#station-list","text":"The station list view allows you to jump arbitrary between stations. It also has a recording functionality for multiple stream recording.","title":"Station List"},{"location":"#debug-view","text":"The debug view allows you to control specific elements of the receiver. Especially : RF Gain Filter Cut off-frequency and transition width Tau Pre-emphasis / De-emphasis Networks It also features 5 views of the received signal, including FM Demodulated Signal Waterfall display of demodulated signal L+R stereo display RDS Constellation Audio Display","title":"Debug View"},{"location":"about/","text":"About GNU Radio FM Receiver Project Overview The GNU Radio FM Receiver is a modern, software-defined radio (SDR) application that provides comprehensive FM radio reception capabilities. Built using GNU Radio for signal processing and PyQt5 for the user interface, this project demonstrates how to build a simple or advance application using GNU Radio for backend. Project Goals Educational : Demonstrate practical use of GNU Radio as DSP backend Functional : Provide a fully-featured FM radio receiver Modern : Implement contemporary UI/UX design patterns Extensible : Create a foundation for advanced radio applications Key Features Core Radio Functionality FM Band Reception : Full coverage of 88-108 MHz FM broadcast band RDS Support : Radio Data System decoding for station information High-Quality Audio : Professional-grade audio processing and output Manual Tuning : Precise frequency control with real-time feedback Station Management Automated Scanning : Intelligent station discovery across the FM band Station Memory : Persistent storage of discovered stations Quick Navigation : One-click station switching and browsing Recording Capabilities Audio Recording : High-quality WAV file recording Timestamped Files : Automatic filename generation with date/time Configurable Output : User-selectable recording directory Real-time Control : Start/stop recording during playback Advanced Features Debug Interface : Comprehensive signal analysis tools Spectrum Analysis : Real-time frequency domain visualization Waterfall Display : Time-frequency signal visualization Constellation Plots : Digital signal quality assessment Filter Controls : Adjustable RF gain and filtering parameters Technical Architecture Signal Processing Chain SDR Hardware \u2192 GNU Radio Flowgraph \u2192 Audio Processing \u2192 PyQt5 UI Core Components GNU Radio Integration Custom rds_rx flowgraph for FM demodulation Real-time signal processing and filtering RDS data extraction and decoding Audio output and recording pipeline PyQt5 User Interface Modern, responsive design Tabbed interface for different application modes Custom widgets for radio-specific controls Real-time visualization integration Configuration Management Persistent settings storage Station memory across sessions User preference management Automatic configuration backup Threading Architecture Main Thread : UI updates and user interaction Scanner Thread : Background frequency scanning GNU Radio Thread : Real-time signal processing Technology Stack Core Technologies Python 3.8+ : Primary development language GNU Radio 3.8+ : Signal processing framework PyQt5 : Cross-platform GUI framework NumPy : Numerical computing support Signal Processing Digital Signal Processing : Real-time filtering and demodulation RDS Decoding : Radio Data System implementation Audio Processing : High-quality audio pipeline Spectrum Analysis : FFT-based frequency analysis Hardware Support RTL-SDR : USB dongle SDR support HackRF : Professional SDR hardware USRP : Universal Software Radio Peripheral BladeRF : High-performance SDR platform Contributing This project is part of gsoc 2025 under GNU Radio organization, and contribution is welcomed Areas for Contribution Bug Reports : Help identify and fix issues Feature Requests : Suggest new functionality Documentation : Improve guides and examples Testing : Verify compatibility across platforms UI/UX : Enhance user interface design Project Status Current Version : 1.0.0 \u2705 Core FM reception functionality \u2705 Station scanning and management \u2705 Audio recording capabilities \u2705 RDS data decoding \u2705 Debug and analysis tools License This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details. Acknowledgments Special Thanks GNU Radio Community : Especially my mentors for thier excellent guidance throughout the project period.","title":"About"},{"location":"about/#about-gnu-radio-fm-receiver","text":"","title":"About GNU Radio FM Receiver"},{"location":"about/#project-overview","text":"The GNU Radio FM Receiver is a modern, software-defined radio (SDR) application that provides comprehensive FM radio reception capabilities. Built using GNU Radio for signal processing and PyQt5 for the user interface, this project demonstrates how to build a simple or advance application using GNU Radio for backend.","title":"Project Overview"},{"location":"about/#project-goals","text":"Educational : Demonstrate practical use of GNU Radio as DSP backend Functional : Provide a fully-featured FM radio receiver Modern : Implement contemporary UI/UX design patterns Extensible : Create a foundation for advanced radio applications","title":"Project Goals"},{"location":"about/#key-features","text":"","title":"Key Features"},{"location":"about/#core-radio-functionality","text":"FM Band Reception : Full coverage of 88-108 MHz FM broadcast band RDS Support : Radio Data System decoding for station information High-Quality Audio : Professional-grade audio processing and output Manual Tuning : Precise frequency control with real-time feedback","title":"Core Radio Functionality"},{"location":"about/#station-management","text":"Automated Scanning : Intelligent station discovery across the FM band Station Memory : Persistent storage of discovered stations Quick Navigation : One-click station switching and browsing","title":"Station Management"},{"location":"about/#recording-capabilities","text":"Audio Recording : High-quality WAV file recording Timestamped Files : Automatic filename generation with date/time Configurable Output : User-selectable recording directory Real-time Control : Start/stop recording during playback","title":"Recording Capabilities"},{"location":"about/#advanced-features","text":"Debug Interface : Comprehensive signal analysis tools Spectrum Analysis : Real-time frequency domain visualization Waterfall Display : Time-frequency signal visualization Constellation Plots : Digital signal quality assessment Filter Controls : Adjustable RF gain and filtering parameters","title":"Advanced Features"},{"location":"about/#technical-architecture","text":"","title":"Technical Architecture"},{"location":"about/#signal-processing-chain","text":"SDR Hardware \u2192 GNU Radio Flowgraph \u2192 Audio Processing \u2192 PyQt5 UI","title":"Signal Processing Chain"},{"location":"about/#core-components","text":"","title":"Core Components"},{"location":"about/#gnu-radio-integration","text":"Custom rds_rx flowgraph for FM demodulation Real-time signal processing and filtering RDS data extraction and decoding Audio output and recording pipeline","title":"GNU Radio Integration"},{"location":"about/#pyqt5-user-interface","text":"Modern, responsive design Tabbed interface for different application modes Custom widgets for radio-specific controls Real-time visualization integration","title":"PyQt5 User Interface"},{"location":"about/#configuration-management","text":"Persistent settings storage Station memory across sessions User preference management Automatic configuration backup","title":"Configuration Management"},{"location":"about/#threading-architecture","text":"Main Thread : UI updates and user interaction Scanner Thread : Background frequency scanning GNU Radio Thread : Real-time signal processing","title":"Threading Architecture"},{"location":"about/#technology-stack","text":"","title":"Technology Stack"},{"location":"about/#core-technologies","text":"Python 3.8+ : Primary development language GNU Radio 3.8+ : Signal processing framework PyQt5 : Cross-platform GUI framework NumPy : Numerical computing support","title":"Core Technologies"},{"location":"about/#signal-processing","text":"Digital Signal Processing : Real-time filtering and demodulation RDS Decoding : Radio Data System implementation Audio Processing : High-quality audio pipeline Spectrum Analysis : FFT-based frequency analysis","title":"Signal Processing"},{"location":"about/#hardware-support","text":"RTL-SDR : USB dongle SDR support HackRF : Professional SDR hardware USRP : Universal Software Radio Peripheral BladeRF : High-performance SDR platform","title":"Hardware Support"},{"location":"about/#contributing","text":"This project is part of gsoc 2025 under GNU Radio organization, and contribution is welcomed","title":"Contributing"},{"location":"about/#areas-for-contribution","text":"Bug Reports : Help identify and fix issues Feature Requests : Suggest new functionality Documentation : Improve guides and examples Testing : Verify compatibility across platforms UI/UX : Enhance user interface design","title":"Areas for Contribution"},{"location":"about/#project-status","text":"","title":"Project Status"},{"location":"about/#current-version-100","text":"\u2705 Core FM reception functionality \u2705 Station scanning and management \u2705 Audio recording capabilities \u2705 RDS data decoding \u2705 Debug and analysis tools","title":"Current Version: 1.0.0"},{"location":"about/#license","text":"This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details.","title":"License"},{"location":"about/#acknowledgments","text":"","title":"Acknowledgments"},{"location":"about/#special-thanks","text":"GNU Radio Community : Especially my mentors for thier excellent guidance throughout the project period.","title":"Special Thanks"},{"location":"tutorials/","text":"Tutorials This comprehensive guide demonstrates how to integrate GNU Radio flowgraphs into custom Python GUI applications, giving you full programmatic control over signal processing workflows. GNU Radio uses a concept called \"flowgraphs\" - visual representations of signal processing chains where blocks (filters, modulators, sources, sinks) are connected together. When you create a flowgraph in GNU Radio Companion (GRC), it generates Python code that can be integrated into your applications. Integrating GNU Radio to you Python App Create Your Flow graph Start by building a simple FM receiver flow graph following this tutorial RTL-SDR FM Receiver tutorial . Alternatively you can download the GRC file directly from wget https://raw.githubusercontent.com/StudHamza/GNU-Radio-FM-App/main/src/fm_receiver/flowgraphs/rds_rx.grc Run the file using GNU Radio Companion, and open the generated python file. Understanding the Generated Code When you generate Python code from GRC, you get a class structure like this: class simple_fm_receiver(gr.top_block, Qt.QWidget): def __init__(self): gr.top_block.__init__(self, \"Simple FM Receiver\") Qt.QWidget.__init__(self) # Variables (can be modified at runtime) self.freq = freq = 101.1e6 # Center frequency self.samp_rate = samp_rate = 2048000 # Sample rate # Blocks self.rtlsdr_source = osmosdr.source(args=\"numchan=1\") self.low_pass_filter = filter.fir_filter_ccf(...) self.analog_wfm_rcv = analog.wfm_rcv(...) self.audio_sink = audio.sink(48000) # Connections self.connect((self.rtlsdr_source, 0), (self.low_pass_filter, 0)) # ... more connections def closeEvent(self, event): self.settings = Qt.QSettings(\"GNU Radio\", \"fm_receiver\") self.settings.setValue(\"geometry\", self.saveGeometry()) self.stop() self.wait() event.accept() # Getters and Setters def get_samp_rate(self): return self.samp_rate def set_samp_rate(self, samp_rate): self.samp_rate = samp_rate def get_freq(self): return self.freq def set_freq(self, freq): self.freq = freq self.qtgui_sink_x_0.set_frequency_range(self.freq, 2.048e6) self.soapy_rtlsdr_source_0.set_frequency(0, self.freq) def get_fft_size(self): return self.fft_size def set_fft_size(self, fft_size): self.fft_size = fft_size Look for the main function at the very end of the file. def main(top_block_cls=simple_fm_receiver, options=None): tb = top_block_cls() def sig_handler(sig=None, frame=None): tb.stop() tb.wait() sys.exit(0) signal.signal(signal.SIGINT, sig_handler) signal.signal(signal.SIGTERM, sig_handler) tb.start() try: input('Press Enter to quit: ') except EOFError: pass tb.stop() tb.wait() if __name__ == '__main__': main() The parameter top_block_clls=simple_fm_receiver is your flow graph, which inherits the gr.top_block . The Key Methods of interest here are Start : Start the contained flowgraph. Creates one or more threads to execute the flow graph. Returns to the caller once the threads are created. Stop : Stop the running flowgraph. Notifies each thread created by the scheduler to shutdown, then returns to caller. Wait :Wait for a flowgraph to complete. Flowgraphs complete when either (1) all blocks indicate that they are done, or (2) after stop() has been called to request shutdown. Your application Create a new python virtual environment make sure to include system packages so that your code can find GNU Radio. # Create environment python -m venv .venv --system-site-packages # Activate (Linux/Mac) source .venv/bin/activate # Activate (Windows) .venv\\Scripts\\activate Create your application file, app.py and include the following code to start a pyqt5 application with a single button to toggle the flowgraph, make sure that both the flowgraph file and your app is in same directory, or can access one another to import your top block fm receiver. import sys from PyQt5.QtWidgets import QApplication, QPushButton, QWidget, QVBoxLayout # First Import your flowgraph from yourdirectory.simple_fm import simple_fm class FM(QWidget): def __init__(self): super().__init__() self.setWindowTitle(\"PyQt5 Simple FM Example\") # Instantiate FM Receiver App self.tb = simple_fm() # State variable self.listening = False # Layout layout = QVBoxLayout() # Button self.button = QPushButton(\"Start Listening\") self.button.clicked.connect(self.toggle_listening) # connect click event layout.addWidget(self.button) self.setLayout(layout) def toggle_listening(self): \"\"\"Toggle listening state and update button text.\"\"\" self.listening = not self.listening if self.listening: self.button.setText(\"Stop Listening\") print(\"Listening started...\") self.tb.start() else: self.button.setText(\"Start Listening\") print(\"Listening stopped.\") self.tb.stop() self.tb.wait() if __name__ == \"__main__\": app = QApplication(sys.argv) window = FM() window.show() sys.exit(app.exec_()) The first step is to import your flowgraph and instantiate it in the init of your application in order to control it from anywhere. from yourdirectory.simple_fm import simple_fm . . . # Instantiate FM Receiver App self.tb = simple_fm() Then the button will toggle the flowgraph allowing the user to stop or continue the flowgraph on command. def toggle_listening(self): \"\"\"Toggle listening state and update button text.\"\"\" self.listening = not self.listening if self.listening: self.button.setText(\"Stop Listening\") print(\"Listening started...\") self.tb.start() else: self.button.setText(\"Start Listening\") print(\"Listening stopped.\") self.tb.stop() self.tb.wait() Run your application Finally, Run your application, and you now have your first python application with GRC backend. This way you can control anything in your flowgraph, from simple setting the center frequency to more advanced usage like disconnected and connecting blocks. Advance Features This section covers more advance controls that can make your python app manage every single detail of your flowgraph. This explanation is specific for the FM Application but can be applied anywhere else. The topics covered in this tutorial are: Variable Control Use GRC GUI elements in your python application Using paramters for your flowgraph Advance control over blocks, by disconnecting and reconnecting blocks Setting Variables Using GUI Blocks Disconnecting and Connecting Blocks Parameters RDS Integration In my case, the rds_rx.py runs this code to instantiate an object of our flow graph. def main(top_block_cls=rds_rx, options=None): if options is None: options = argument_parser().parse_args() if StrictVersion(\"4.5.0\") <= StrictVersion(Qt.qVersion()) < StrictVersion(\"5.0.0\"): style = gr.prefs().get_string('qtgui', 'style', 'raster') Qt.QApplication.setGraphicsSystem(style) qapp = Qt.QApplication(sys.argv) tb = top_block_cls() tb.start() tb.show() def sig_handler(sig=None, frame=None): tb.stop() tb.wait() Qt.QApplication.quit() signal.signal(signal.SIGINT, sig_handler) signal.signal(signal.SIGTERM, sig_handler) timer = Qt.QTimer() timer.start(500) timer.timeout.connect(lambda: None) qapp.exec_() if __name__ == '__main__': main() As you can see there are three main functions to","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"This comprehensive guide demonstrates how to integrate GNU Radio flowgraphs into custom Python GUI applications, giving you full programmatic control over signal processing workflows. GNU Radio uses a concept called \"flowgraphs\" - visual representations of signal processing chains where blocks (filters, modulators, sources, sinks) are connected together. When you create a flowgraph in GNU Radio Companion (GRC), it generates Python code that can be integrated into your applications.","title":"Tutorials"},{"location":"tutorials/#integrating-gnu-radio-to-you-python-app","text":"","title":"Integrating GNU Radio to you Python App"},{"location":"tutorials/#create-your-flow-graph","text":"Start by building a simple FM receiver flow graph following this tutorial RTL-SDR FM Receiver tutorial . Alternatively you can download the GRC file directly from wget https://raw.githubusercontent.com/StudHamza/GNU-Radio-FM-App/main/src/fm_receiver/flowgraphs/rds_rx.grc Run the file using GNU Radio Companion, and open the generated python file.","title":"Create Your Flow graph"},{"location":"tutorials/#understanding-the-generated-code","text":"When you generate Python code from GRC, you get a class structure like this: class simple_fm_receiver(gr.top_block, Qt.QWidget): def __init__(self): gr.top_block.__init__(self, \"Simple FM Receiver\") Qt.QWidget.__init__(self) # Variables (can be modified at runtime) self.freq = freq = 101.1e6 # Center frequency self.samp_rate = samp_rate = 2048000 # Sample rate # Blocks self.rtlsdr_source = osmosdr.source(args=\"numchan=1\") self.low_pass_filter = filter.fir_filter_ccf(...) self.analog_wfm_rcv = analog.wfm_rcv(...) self.audio_sink = audio.sink(48000) # Connections self.connect((self.rtlsdr_source, 0), (self.low_pass_filter, 0)) # ... more connections def closeEvent(self, event): self.settings = Qt.QSettings(\"GNU Radio\", \"fm_receiver\") self.settings.setValue(\"geometry\", self.saveGeometry()) self.stop() self.wait() event.accept() # Getters and Setters def get_samp_rate(self): return self.samp_rate def set_samp_rate(self, samp_rate): self.samp_rate = samp_rate def get_freq(self): return self.freq def set_freq(self, freq): self.freq = freq self.qtgui_sink_x_0.set_frequency_range(self.freq, 2.048e6) self.soapy_rtlsdr_source_0.set_frequency(0, self.freq) def get_fft_size(self): return self.fft_size def set_fft_size(self, fft_size): self.fft_size = fft_size Look for the main function at the very end of the file. def main(top_block_cls=simple_fm_receiver, options=None): tb = top_block_cls() def sig_handler(sig=None, frame=None): tb.stop() tb.wait() sys.exit(0) signal.signal(signal.SIGINT, sig_handler) signal.signal(signal.SIGTERM, sig_handler) tb.start() try: input('Press Enter to quit: ') except EOFError: pass tb.stop() tb.wait() if __name__ == '__main__': main() The parameter top_block_clls=simple_fm_receiver is your flow graph, which inherits the gr.top_block . The Key Methods of interest here are Start : Start the contained flowgraph. Creates one or more threads to execute the flow graph. Returns to the caller once the threads are created. Stop : Stop the running flowgraph. Notifies each thread created by the scheduler to shutdown, then returns to caller. Wait :Wait for a flowgraph to complete. Flowgraphs complete when either (1) all blocks indicate that they are done, or (2) after stop() has been called to request shutdown.","title":"Understanding the Generated Code"},{"location":"tutorials/#your-application","text":"Create a new python virtual environment make sure to include system packages so that your code can find GNU Radio. # Create environment python -m venv .venv --system-site-packages # Activate (Linux/Mac) source .venv/bin/activate # Activate (Windows) .venv\\Scripts\\activate Create your application file, app.py and include the following code to start a pyqt5 application with a single button to toggle the flowgraph, make sure that both the flowgraph file and your app is in same directory, or can access one another to import your top block fm receiver. import sys from PyQt5.QtWidgets import QApplication, QPushButton, QWidget, QVBoxLayout # First Import your flowgraph from yourdirectory.simple_fm import simple_fm class FM(QWidget): def __init__(self): super().__init__() self.setWindowTitle(\"PyQt5 Simple FM Example\") # Instantiate FM Receiver App self.tb = simple_fm() # State variable self.listening = False # Layout layout = QVBoxLayout() # Button self.button = QPushButton(\"Start Listening\") self.button.clicked.connect(self.toggle_listening) # connect click event layout.addWidget(self.button) self.setLayout(layout) def toggle_listening(self): \"\"\"Toggle listening state and update button text.\"\"\" self.listening = not self.listening if self.listening: self.button.setText(\"Stop Listening\") print(\"Listening started...\") self.tb.start() else: self.button.setText(\"Start Listening\") print(\"Listening stopped.\") self.tb.stop() self.tb.wait() if __name__ == \"__main__\": app = QApplication(sys.argv) window = FM() window.show() sys.exit(app.exec_()) The first step is to import your flowgraph and instantiate it in the init of your application in order to control it from anywhere. from yourdirectory.simple_fm import simple_fm . . . # Instantiate FM Receiver App self.tb = simple_fm() Then the button will toggle the flowgraph allowing the user to stop or continue the flowgraph on command. def toggle_listening(self): \"\"\"Toggle listening state and update button text.\"\"\" self.listening = not self.listening if self.listening: self.button.setText(\"Stop Listening\") print(\"Listening started...\") self.tb.start() else: self.button.setText(\"Start Listening\") print(\"Listening stopped.\") self.tb.stop() self.tb.wait()","title":"Your application"},{"location":"tutorials/#run-your-application","text":"Finally, Run your application, and you now have your first python application with GRC backend. This way you can control anything in your flowgraph, from simple setting the center frequency to more advanced usage like disconnected and connecting blocks.","title":"Run your application"},{"location":"tutorials/#advance-features","text":"This section covers more advance controls that can make your python app manage every single detail of your flowgraph. This explanation is specific for the FM Application but can be applied anywhere else. The topics covered in this tutorial are: Variable Control Use GRC GUI elements in your python application Using paramters for your flowgraph Advance control over blocks, by disconnecting and reconnecting blocks","title":"Advance Features"},{"location":"tutorials/#setting-variables","text":"","title":"Setting Variables"},{"location":"tutorials/#using-gui-blocks","text":"","title":"Using GUI Blocks"},{"location":"tutorials/#disconnecting-and-connecting-blocks","text":"","title":"Disconnecting and Connecting Blocks"},{"location":"tutorials/#parameters","text":"","title":"Parameters"},{"location":"tutorials/#rds-integration","text":"In my case, the rds_rx.py runs this code to instantiate an object of our flow graph. def main(top_block_cls=rds_rx, options=None): if options is None: options = argument_parser().parse_args() if StrictVersion(\"4.5.0\") <= StrictVersion(Qt.qVersion()) < StrictVersion(\"5.0.0\"): style = gr.prefs().get_string('qtgui', 'style', 'raster') Qt.QApplication.setGraphicsSystem(style) qapp = Qt.QApplication(sys.argv) tb = top_block_cls() tb.start() tb.show() def sig_handler(sig=None, frame=None): tb.stop() tb.wait() Qt.QApplication.quit() signal.signal(signal.SIGINT, sig_handler) signal.signal(signal.SIGTERM, sig_handler) timer = Qt.QTimer() timer.start(500) timer.timeout.connect(lambda: None) qapp.exec_() if __name__ == '__main__': main() As you can see there are three main functions to","title":"RDS Integration"}]}