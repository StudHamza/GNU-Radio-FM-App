{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to GNU Radio FM application GNU Radio \u2013 A free & open-source toolkit for software radio development. This project demonstrates how to use GNU Radio flow graphs to abstract the signal processing back end from your application frontend to build a modern functional application in no time. The key features of this project are: Spectrum Scanning and FM Detection RDS Decoding Advance Usage of GNU Radio flowgraphs Multiple Streaming Functionality The project directory is: \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 config.json \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u251c\u2500\u2500 img/ \u2502 \u2502 \u2514\u2500\u2500 favicon.ico \u2502 \u2514\u2500\u2500 index.md \u251c\u2500\u2500 downloads \u2502 \u2514\u2500\u2500 2025-08-18_09-01-32.wav \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 Output.wav \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 fm_receiver \u2502 \u251c\u2500\u2500 app.py \u2502 \u251c\u2500\u2500 core/ \u2502 \u2502 \u251c\u2500\u2500 config_manager.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 flowgraphs/ \u2502 \u2502 \u251c\u2500\u2500 fm_receiver.py \u2502 \u2502 \u251c\u2500\u2500 fm_scanner.{grc,py} \u2502 \u2502 \u251c\u2500\u2500 MultipleRecorder.{block.yml,py} \u2502 \u2502 \u251c\u2500\u2500 rds_rx.{grc,py} \u2502 \u2502 \u251c\u2500\u2500 Recorder.grc \u2502 \u2502 \u251c\u2500\u2500 rds_rx_epy_block_0.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 gui/ \u2502 \u2502 \u251c\u2500\u2500 config_dialog.py \u2502 \u2502 \u251c\u2500\u2500 frequency_slider.py \u2502 \u2502 \u251c\u2500\u2500 info_window.py \u2502 \u2502 \u251c\u2500\u2500 main_window.py \u2502 \u2502 \u251c\u2500\u2500 scan_thread.py \u2502 \u2502 \u251c\u2500\u2500 station_button.py \u2502 \u2502 \u251c\u2500\u2500 volume_slider.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 main.py \u2502 \u251c\u2500\u2500 resources/icons/record.png \u2502 \u251c\u2500\u2500 utils/ \u2502 \u2502 \u251c\u2500\u2500 fm_scanner.py \u2502 \u2502 \u251c\u2500\u2500 logging_config.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u2514\u2500\u2500 __pycache__/... \u251c\u2500\u2500 structure.txt \u2514\u2500\u2500 uv.lock Installation Requirements Ensure the following dependencies are installed on your system: GNU Radio gr-rds uv Python 3.10 numpy , matplotlib (automatically handled by uv ) SoapySDR ( sudo apt install soapysdr-module-all ) Running the Project Using uv Install uv by following the installation guide . Make sure GNU Radio and gr-rds are properly installed on your system. Run the FM receiver: uv run src/fm_receiver/main.py Note: Before running, ensure your virtual environment is created with system site packages enabled: python3 -m venv .venv --system-site-packages After running, you should be prompted with the SDR config manager that allows you to choose from attached devices. Home Page In the home page you can listen to different stations, the next and previous buttons lets you jump between adjacent stations. The RDS information is displayed at the button, along with a frequency slider that shows you what frequency you're listening too. You can also record current sessions and scan area for possible FM stations. Station List The station list view allows you to jump arbitrary between stations. It also has a recording functionality for multiple stream recording. Debug View The debug view allows you to control specific elements of the receiver. Especially : RF Gain Filter Cut off-frequency and transition width Tau Pre-emphasis / De-emphasis Networks It also features 5 views of the received signal, including FM Demodulated Signal Waterfall display of demodulated signal L+R stereo display RDS Constellation Audio Display","title":"Home"},{"location":"#welcome-to-gnu-radio-fm-application","text":"GNU Radio \u2013 A free & open-source toolkit for software radio development. This project demonstrates how to use GNU Radio flow graphs to abstract the signal processing back end from your application frontend to build a modern functional application in no time. The key features of this project are: Spectrum Scanning and FM Detection RDS Decoding Advance Usage of GNU Radio flowgraphs Multiple Streaming Functionality The project directory is: \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 config.json \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 about.md \u2502 \u251c\u2500\u2500 img/ \u2502 \u2502 \u2514\u2500\u2500 favicon.ico \u2502 \u2514\u2500\u2500 index.md \u251c\u2500\u2500 downloads \u2502 \u2514\u2500\u2500 2025-08-18_09-01-32.wav \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 Output.wav \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 fm_receiver \u2502 \u251c\u2500\u2500 app.py \u2502 \u251c\u2500\u2500 core/ \u2502 \u2502 \u251c\u2500\u2500 config_manager.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 flowgraphs/ \u2502 \u2502 \u251c\u2500\u2500 fm_receiver.py \u2502 \u2502 \u251c\u2500\u2500 fm_scanner.{grc,py} \u2502 \u2502 \u251c\u2500\u2500 MultipleRecorder.{block.yml,py} \u2502 \u2502 \u251c\u2500\u2500 rds_rx.{grc,py} \u2502 \u2502 \u251c\u2500\u2500 Recorder.grc \u2502 \u2502 \u251c\u2500\u2500 rds_rx_epy_block_0.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 gui/ \u2502 \u2502 \u251c\u2500\u2500 config_dialog.py \u2502 \u2502 \u251c\u2500\u2500 frequency_slider.py \u2502 \u2502 \u251c\u2500\u2500 info_window.py \u2502 \u2502 \u251c\u2500\u2500 main_window.py \u2502 \u2502 \u251c\u2500\u2500 scan_thread.py \u2502 \u2502 \u251c\u2500\u2500 station_button.py \u2502 \u2502 \u251c\u2500\u2500 volume_slider.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u251c\u2500\u2500 main.py \u2502 \u251c\u2500\u2500 resources/icons/record.png \u2502 \u251c\u2500\u2500 utils/ \u2502 \u2502 \u251c\u2500\u2500 fm_scanner.py \u2502 \u2502 \u251c\u2500\u2500 logging_config.py \u2502 \u2502 \u2514\u2500\u2500 __pycache__/... \u2502 \u2514\u2500\u2500 __pycache__/... \u251c\u2500\u2500 structure.txt \u2514\u2500\u2500 uv.lock","title":"Welcome to GNU Radio FM application"},{"location":"#installation","text":"","title":"Installation"},{"location":"#requirements","text":"Ensure the following dependencies are installed on your system: GNU Radio gr-rds uv Python 3.10 numpy , matplotlib (automatically handled by uv ) SoapySDR ( sudo apt install soapysdr-module-all )","title":"Requirements"},{"location":"#running-the-project","text":"","title":"Running the Project"},{"location":"#using-uv","text":"Install uv by following the installation guide . Make sure GNU Radio and gr-rds are properly installed on your system. Run the FM receiver: uv run src/fm_receiver/main.py Note: Before running, ensure your virtual environment is created with system site packages enabled: python3 -m venv .venv --system-site-packages After running, you should be prompted with the SDR config manager that allows you to choose from attached devices.","title":"Using uv"},{"location":"#home-page","text":"In the home page you can listen to different stations, the next and previous buttons lets you jump between adjacent stations. The RDS information is displayed at the button, along with a frequency slider that shows you what frequency you're listening too. You can also record current sessions and scan area for possible FM stations.","title":"Home Page"},{"location":"#station-list","text":"The station list view allows you to jump arbitrary between stations. It also has a recording functionality for multiple stream recording.","title":"Station List"},{"location":"#debug-view","text":"The debug view allows you to control specific elements of the receiver. Especially : RF Gain Filter Cut off-frequency and transition width Tau Pre-emphasis / De-emphasis Networks It also features 5 views of the received signal, including FM Demodulated Signal Waterfall display of demodulated signal L+R stereo display RDS Constellation Audio Display","title":"Debug View"},{"location":"about/","text":"About GNU Radio FM Receiver Project Overview The GNU Radio FM Receiver is a modern, software-defined radio (SDR) application that provides comprehensive FM radio reception capabilities. Built using GNU Radio for signal processing and PyQt5 for the user interface, this project demonstrates how to build a simple or advance application using GNU Radio for backend. Project Goals Educational : Demonstrate practical use of GNU Radio as DSP backend Functional : Provide a fully-featured FM radio receiver Modern : Implement contemporary UI/UX design patterns Extensible : Create a foundation for advanced radio applications Key Features Core Radio Functionality FM Band Reception : Full coverage of 88-108 MHz FM broadcast band RDS Support : Radio Data System decoding for station information High-Quality Audio : Professional-grade audio processing and output Manual Tuning : Precise frequency control with real-time feedback Station Management Automated Scanning : Intelligent station discovery across the FM band Station Memory : Persistent storage of discovered stations Quick Navigation : One-click station switching and browsing Recording Capabilities Audio Recording : High-quality WAV file recording Timestamped Files : Automatic filename generation with date/time Configurable Output : User-selectable recording directory Real-time Control : Start/stop recording during playback Advanced Features Debug Interface : Comprehensive signal analysis tools Spectrum Analysis : Real-time frequency domain visualization Waterfall Display : Time-frequency signal visualization Constellation Plots : Digital signal quality assessment Filter Controls : Adjustable RF gain and filtering parameters Technical Architecture Signal Processing Chain SDR Hardware \u2192 GNU Radio Flowgraph \u2192 Audio Processing \u2192 PyQt5 UI Core Components GNU Radio Integration Custom rds_rx flowgraph for FM demodulation Real-time signal processing and filtering RDS data extraction and decoding Audio output and recording pipeline PyQt5 User Interface Modern, responsive design Tabbed interface for different application modes Custom widgets for radio-specific controls Real-time visualization integration Configuration Management Persistent settings storage Station memory across sessions User preference management Automatic configuration backup Threading Architecture Main Thread : UI updates and user interaction Scanner Thread : Background frequency scanning GNU Radio Thread : Real-time signal processing Technology Stack Core Technologies Python 3.8+ : Primary development language GNU Radio 3.8+ : Signal processing framework PyQt5 : Cross-platform GUI framework NumPy : Numerical computing support Signal Processing Digital Signal Processing : Real-time filtering and demodulation RDS Decoding : Radio Data System implementation Audio Processing : High-quality audio pipeline Spectrum Analysis : FFT-based frequency analysis Hardware Support RTL-SDR : USB dongle SDR support HackRF : Professional SDR hardware USRP : Universal Software Radio Peripheral BladeRF : High-performance SDR platform Contributing This project is part of gsoc 2025 under GNU Radio organization, and contribution is welcomed Areas for Contribution Bug Reports : Help identify and fix issues Feature Requests : Suggest new functionality Documentation : Improve guides and examples Testing : Verify compatibility across platforms UI/UX : Enhance user interface design Project Status Current Version : 1.0.0 \u2705 Core FM reception functionality \u2705 Station scanning and management \u2705 Audio recording capabilities \u2705 RDS data decoding \u2705 Debug and analysis tools License This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details. Acknowledgments Special Thanks GNU Radio Community : Especially my mentors for thier excellent guidance throughout the project period.","title":"About"},{"location":"about/#about-gnu-radio-fm-receiver","text":"","title":"About GNU Radio FM Receiver"},{"location":"about/#project-overview","text":"The GNU Radio FM Receiver is a modern, software-defined radio (SDR) application that provides comprehensive FM radio reception capabilities. Built using GNU Radio for signal processing and PyQt5 for the user interface, this project demonstrates how to build a simple or advance application using GNU Radio for backend.","title":"Project Overview"},{"location":"about/#project-goals","text":"Educational : Demonstrate practical use of GNU Radio as DSP backend Functional : Provide a fully-featured FM radio receiver Modern : Implement contemporary UI/UX design patterns Extensible : Create a foundation for advanced radio applications","title":"Project Goals"},{"location":"about/#key-features","text":"","title":"Key Features"},{"location":"about/#core-radio-functionality","text":"FM Band Reception : Full coverage of 88-108 MHz FM broadcast band RDS Support : Radio Data System decoding for station information High-Quality Audio : Professional-grade audio processing and output Manual Tuning : Precise frequency control with real-time feedback","title":"Core Radio Functionality"},{"location":"about/#station-management","text":"Automated Scanning : Intelligent station discovery across the FM band Station Memory : Persistent storage of discovered stations Quick Navigation : One-click station switching and browsing","title":"Station Management"},{"location":"about/#recording-capabilities","text":"Audio Recording : High-quality WAV file recording Timestamped Files : Automatic filename generation with date/time Configurable Output : User-selectable recording directory Real-time Control : Start/stop recording during playback","title":"Recording Capabilities"},{"location":"about/#advanced-features","text":"Debug Interface : Comprehensive signal analysis tools Spectrum Analysis : Real-time frequency domain visualization Waterfall Display : Time-frequency signal visualization Constellation Plots : Digital signal quality assessment Filter Controls : Adjustable RF gain and filtering parameters","title":"Advanced Features"},{"location":"about/#technical-architecture","text":"","title":"Technical Architecture"},{"location":"about/#signal-processing-chain","text":"SDR Hardware \u2192 GNU Radio Flowgraph \u2192 Audio Processing \u2192 PyQt5 UI","title":"Signal Processing Chain"},{"location":"about/#core-components","text":"","title":"Core Components"},{"location":"about/#gnu-radio-integration","text":"Custom rds_rx flowgraph for FM demodulation Real-time signal processing and filtering RDS data extraction and decoding Audio output and recording pipeline","title":"GNU Radio Integration"},{"location":"about/#pyqt5-user-interface","text":"Modern, responsive design Tabbed interface for different application modes Custom widgets for radio-specific controls Real-time visualization integration","title":"PyQt5 User Interface"},{"location":"about/#configuration-management","text":"Persistent settings storage Station memory across sessions User preference management Automatic configuration backup","title":"Configuration Management"},{"location":"about/#threading-architecture","text":"Main Thread : UI updates and user interaction Scanner Thread : Background frequency scanning GNU Radio Thread : Real-time signal processing","title":"Threading Architecture"},{"location":"about/#technology-stack","text":"","title":"Technology Stack"},{"location":"about/#core-technologies","text":"Python 3.8+ : Primary development language GNU Radio 3.8+ : Signal processing framework PyQt5 : Cross-platform GUI framework NumPy : Numerical computing support","title":"Core Technologies"},{"location":"about/#signal-processing","text":"Digital Signal Processing : Real-time filtering and demodulation RDS Decoding : Radio Data System implementation Audio Processing : High-quality audio pipeline Spectrum Analysis : FFT-based frequency analysis","title":"Signal Processing"},{"location":"about/#hardware-support","text":"RTL-SDR : USB dongle SDR support HackRF : Professional SDR hardware USRP : Universal Software Radio Peripheral BladeRF : High-performance SDR platform","title":"Hardware Support"},{"location":"about/#contributing","text":"This project is part of gsoc 2025 under GNU Radio organization, and contribution is welcomed","title":"Contributing"},{"location":"about/#areas-for-contribution","text":"Bug Reports : Help identify and fix issues Feature Requests : Suggest new functionality Documentation : Improve guides and examples Testing : Verify compatibility across platforms UI/UX : Enhance user interface design","title":"Areas for Contribution"},{"location":"about/#project-status","text":"","title":"Project Status"},{"location":"about/#current-version-100","text":"\u2705 Core FM reception functionality \u2705 Station scanning and management \u2705 Audio recording capabilities \u2705 RDS data decoding \u2705 Debug and analysis tools","title":"Current Version: 1.0.0"},{"location":"about/#license","text":"This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details.","title":"License"},{"location":"about/#acknowledgments","text":"","title":"Acknowledgments"},{"location":"about/#special-thanks","text":"GNU Radio Community : Especially my mentors for thier excellent guidance throughout the project period.","title":"Special Thanks"},{"location":"scanner/","text":"FM Scanner The scanner block processes incoming complex baseband samples in real time and performs spectrum analysis to detect active signals. Internally, it applies an FFT over a configurable window size to transform the samples into the frequency domain, computes the power in each frequency bin, and compares the results against detection thresholds to identify occupied channels. Users can configure parameters such as FFT size, sample rate, and center frequency to match their application needs. The block outputs information about detected signals, enabling downstream components to react to spectrum activity. Overall Architecture The system consists of two main components: 1. fm_scanner.py - The main GNU Radio flowgraph that handles RF signal acquisition and processing 2. rds_rx_epy_block_0.py - An embedded Python block that performs station detection logic Main Scanner Flow (fm_scanner.py) The signal processing pipeline works as follows: 1. Signal Acquisition self.soapy_rtlsdr_source_0 = soapy.source(dev, \"fc32\", 1, 'True', ...) Uses an RTL-SDR dongle to capture RF signals Samples at 2.048 MHz sample rate Initially tunes to 87 MHz (start of FM band) Captures complex IQ samples 2. Data Limiting self.blocks_head_0 = blocks.head(gr.sizeof_gr_complex*1, num_items) Limits capture to num_items = samp_rate * 2 samples (about 2 seconds of data) 3. FFT Processing self.blocks_stream_to_vector_0 = blocks.stream_to_vector(gr.sizeof_gr_complex*1, fft_size) self.fft_vxx_0 = fft.fft_vcc(fft_size, True, window.blackmanharris(fft_size), True, 1) Converts stream to vectors of size 128 (2^7) Performs FFT with Blackman-Harris windowing This converts time-domain samples to frequency domain 4. Power Calculation self.blocks_complex_to_mag_squared_0 = blocks.complex_to_mag_squared(fft_size) Converts complex FFT output to power spectral density Results in magnitude-squared values representing signal power at each frequency bin Station Detection Logic (rds_rx_epy_block_0.py) This is where the intelligence happens: 1. Initialization Parameters fft_size = 128 : Frequency resolution samp_rate = 2.048e6 : Sample rate freq = 88e6 : Center frequency (88 MHz) threshold = 0.3 : Detection threshold (30%) 2. Frequency Grid Calculation def compute_candidate_freqs(self): step_size = 100e3 # 100 kHz steps start_freq = self.round_to_3_sigfigs(self.freq - self.fft_size * (self.samp_rate / self.fft_size) / 2) end_freq = self.round_to_3_sigfigs(self.freq + self.fft_size * (self.samp_rate / self.fft_size) / 2) self.candidate_freqs = np.arange(start_freq, end_freq, step_size) This creates a grid of candidate station frequencies: - Covers the bandwidth visible in the current FFT window - Uses 100 kHz spacing (typical FM channel spacing in many regions) - Maps frequencies to corresponding FFT bins 3. Power Accumulation for j, station_bin in enumerate(self.candidate_freqs_bin): start_bin = int(station_bin - self.half_station_size) end_bin = int(station_bin + self.half_station_size) potential_station = np.sum(np.abs(data_chunk[start_bin:end_bin])**2) self.power_per_station[j] += potential_station For each candidate frequency: - Calculates which FFT bins correspond to that station - Uses half_station_size based on FM bandwidth (200 kHz) - Sums power across multiple FFT bins for each potential station - Accumulates power over multiple FFT frames for better statistics 4. Station Detection Algorithm normalized_power_per_station = self.normalize(self.power_per_station) active_indices = np.where(normalized_power_per_station > self.threshold)[0] Normalizes power measurements to 0-1 range Identifies candidates above 30% threshold 5. Adjacent Channel Grouping # Group adjacent active indices groups = [] if len(active_indices) > 0: group = [active_indices[0]] for idx in active_indices[1:]: if idx == group[-1] + 1: group.append(idx) else: groups.append(group) group = [idx] This clever algorithm: - Groups adjacent frequency bins that are above threshold - Prevents detecting the same station multiple times - Accounts for FM signals spreading across multiple 100kHz channels 6. Peak Selection for group in groups: max_idx = group[np.argmax(normalized_power_per_station[group])] self.detected_stations.add(float(self.candidate_freqs[max_idx])) For each group of adjacent active channels Selects the frequency with maximum power as the actual station frequency Key Design Features Frequency Resolution : With 128-point FFT and 2.048 MHz sample rate, each bin represents ~16 kHz Station Bandwidth : Assumes 200 kHz FM bandwidth, covering multiple FFT bins per station Robust Detection : Uses power accumulation over time and adjacent channel grouping Threshold-based : Only reports stations above 30% of the maximum detected power Limitations & Observations Fixed Frequency : Currently only scans around 88 MHz - would need frequency hopping for full FM band Single Capture : Takes one 2-second snapshot rather than continuous scanning Simple Threshold : Uses basic power thresholding rather than more sophisticated detection algorithms This is a solid foundation for an FM scanner that could be extended to sweep the entire FM band (88-108 MHz) by iterating through different center frequencies.","title":"Scanner"},{"location":"scanner/#fm-scanner","text":"The scanner block processes incoming complex baseband samples in real time and performs spectrum analysis to detect active signals. Internally, it applies an FFT over a configurable window size to transform the samples into the frequency domain, computes the power in each frequency bin, and compares the results against detection thresholds to identify occupied channels. Users can configure parameters such as FFT size, sample rate, and center frequency to match their application needs. The block outputs information about detected signals, enabling downstream components to react to spectrum activity.","title":"FM Scanner"},{"location":"scanner/#overall-architecture","text":"The system consists of two main components: 1. fm_scanner.py - The main GNU Radio flowgraph that handles RF signal acquisition and processing 2. rds_rx_epy_block_0.py - An embedded Python block that performs station detection logic","title":"Overall Architecture"},{"location":"scanner/#main-scanner-flow-fm_scannerpy","text":"The signal processing pipeline works as follows:","title":"Main Scanner Flow (fm_scanner.py)"},{"location":"scanner/#1-signal-acquisition","text":"self.soapy_rtlsdr_source_0 = soapy.source(dev, \"fc32\", 1, 'True', ...) Uses an RTL-SDR dongle to capture RF signals Samples at 2.048 MHz sample rate Initially tunes to 87 MHz (start of FM band) Captures complex IQ samples","title":"1. Signal Acquisition"},{"location":"scanner/#2-data-limiting","text":"self.blocks_head_0 = blocks.head(gr.sizeof_gr_complex*1, num_items) Limits capture to num_items = samp_rate * 2 samples (about 2 seconds of data)","title":"2. Data Limiting"},{"location":"scanner/#3-fft-processing","text":"self.blocks_stream_to_vector_0 = blocks.stream_to_vector(gr.sizeof_gr_complex*1, fft_size) self.fft_vxx_0 = fft.fft_vcc(fft_size, True, window.blackmanharris(fft_size), True, 1) Converts stream to vectors of size 128 (2^7) Performs FFT with Blackman-Harris windowing This converts time-domain samples to frequency domain","title":"3. FFT Processing"},{"location":"scanner/#4-power-calculation","text":"self.blocks_complex_to_mag_squared_0 = blocks.complex_to_mag_squared(fft_size) Converts complex FFT output to power spectral density Results in magnitude-squared values representing signal power at each frequency bin","title":"4. Power Calculation"},{"location":"scanner/#station-detection-logic-rds_rx_epy_block_0py","text":"This is where the intelligence happens:","title":"Station Detection Logic (rds_rx_epy_block_0.py)"},{"location":"scanner/#1-initialization-parameters","text":"fft_size = 128 : Frequency resolution samp_rate = 2.048e6 : Sample rate freq = 88e6 : Center frequency (88 MHz) threshold = 0.3 : Detection threshold (30%)","title":"1. Initialization Parameters"},{"location":"scanner/#2-frequency-grid-calculation","text":"def compute_candidate_freqs(self): step_size = 100e3 # 100 kHz steps start_freq = self.round_to_3_sigfigs(self.freq - self.fft_size * (self.samp_rate / self.fft_size) / 2) end_freq = self.round_to_3_sigfigs(self.freq + self.fft_size * (self.samp_rate / self.fft_size) / 2) self.candidate_freqs = np.arange(start_freq, end_freq, step_size) This creates a grid of candidate station frequencies: - Covers the bandwidth visible in the current FFT window - Uses 100 kHz spacing (typical FM channel spacing in many regions) - Maps frequencies to corresponding FFT bins","title":"2. Frequency Grid Calculation"},{"location":"scanner/#3-power-accumulation","text":"for j, station_bin in enumerate(self.candidate_freqs_bin): start_bin = int(station_bin - self.half_station_size) end_bin = int(station_bin + self.half_station_size) potential_station = np.sum(np.abs(data_chunk[start_bin:end_bin])**2) self.power_per_station[j] += potential_station For each candidate frequency: - Calculates which FFT bins correspond to that station - Uses half_station_size based on FM bandwidth (200 kHz) - Sums power across multiple FFT bins for each potential station - Accumulates power over multiple FFT frames for better statistics","title":"3. Power Accumulation"},{"location":"scanner/#4-station-detection-algorithm","text":"normalized_power_per_station = self.normalize(self.power_per_station) active_indices = np.where(normalized_power_per_station > self.threshold)[0] Normalizes power measurements to 0-1 range Identifies candidates above 30% threshold","title":"4. Station Detection Algorithm"},{"location":"scanner/#5-adjacent-channel-grouping","text":"# Group adjacent active indices groups = [] if len(active_indices) > 0: group = [active_indices[0]] for idx in active_indices[1:]: if idx == group[-1] + 1: group.append(idx) else: groups.append(group) group = [idx] This clever algorithm: - Groups adjacent frequency bins that are above threshold - Prevents detecting the same station multiple times - Accounts for FM signals spreading across multiple 100kHz channels","title":"5. Adjacent Channel Grouping"},{"location":"scanner/#6-peak-selection","text":"for group in groups: max_idx = group[np.argmax(normalized_power_per_station[group])] self.detected_stations.add(float(self.candidate_freqs[max_idx])) For each group of adjacent active channels Selects the frequency with maximum power as the actual station frequency","title":"6. Peak Selection"},{"location":"scanner/#key-design-features","text":"Frequency Resolution : With 128-point FFT and 2.048 MHz sample rate, each bin represents ~16 kHz Station Bandwidth : Assumes 200 kHz FM bandwidth, covering multiple FFT bins per station Robust Detection : Uses power accumulation over time and adjacent channel grouping Threshold-based : Only reports stations above 30% of the maximum detected power","title":"Key Design Features"},{"location":"scanner/#limitations-observations","text":"Fixed Frequency : Currently only scans around 88 MHz - would need frequency hopping for full FM band Single Capture : Takes one 2-second snapshot rather than continuous scanning Simple Threshold : Uses basic power thresholding rather than more sophisticated detection algorithms This is a solid foundation for an FM scanner that could be extended to sweep the entire FM band (88-108 MHz) by iterating through different center frequencies.","title":"Limitations &amp; Observations"},{"location":"troubleshooting/","text":"","title":"Troubleshooting"},{"location":"tutorials/","text":"Tutorials This comprehensive guide demonstrates how to integrate GNU Radio flowgraphs into custom Python GUI applications, giving you full programmatic control over signal processing workflows. GNU Radio uses a concept called \"flowgraphs\" - visual representations of signal processing chains where blocks (filters, modulators, sources, sinks) are connected together. When you create a flowgraph in GNU Radio Companion (GRC), it generates Python code that can be integrated into your applications. Integrating GNU Radio to you Python App Create Your Flow graph Start by building a simple FM receiver flow graph following this tutorial RTL-SDR FM Receiver tutorial . Alternatively you can download the GRC file directly from wget https://raw.githubusercontent.com/StudHamza/GNU-Radio-FM-App/main/src/fm_receiver/flowgraphs/fm_receiver.grc Run the file using GNU Radio Companion, and open the generated python file. Understanding the Generated Code When you generate Python code from GRC, you get a class structure like this: class simple_fm_receiver(gr.top_block, Qt.QWidget): def __init__(self): gr.top_block.__init__(self, \"Simple FM Receiver\") Qt.QWidget.__init__(self) # Variables (can be modified at runtime) self.freq = freq = 101.1e6 # Center frequency self.samp_rate = samp_rate = 2048000 # Sample rate # Blocks self.rtlsdr_source = osmosdr.source(args=\"numchan=1\") self.low_pass_filter = filter.fir_filter_ccf(...) self.analog_wfm_rcv = analog.wfm_rcv(...) self.audio_sink = audio.sink(48000) # Connections self.connect((self.rtlsdr_source, 0), (self.low_pass_filter, 0)) # ... more connections def closeEvent(self, event): self.settings = Qt.QSettings(\"GNU Radio\", \"fm_receiver\") self.settings.setValue(\"geometry\", self.saveGeometry()) self.stop() self.wait() event.accept() # Getters and Setters def get_samp_rate(self): return self.samp_rate def set_samp_rate(self, samp_rate): self.samp_rate = samp_rate def get_freq(self): return self.freq def set_freq(self, freq): self.freq = freq self.qtgui_sink_x_0.set_frequency_range(self.freq, 2.048e6) self.soapy_rtlsdr_source_0.set_frequency(0, self.freq) def get_fft_size(self): return self.fft_size def set_fft_size(self, fft_size): self.fft_size = fft_size Look for the main function at the very end of the file. def main(top_block_cls=simple_fm_receiver, options=None): tb = top_block_cls() def sig_handler(sig=None, frame=None): tb.stop() tb.wait() sys.exit(0) signal.signal(signal.SIGINT, sig_handler) signal.signal(signal.SIGTERM, sig_handler) tb.start() try: input('Press Enter to quit: ') except EOFError: pass tb.stop() tb.wait() if __name__ == '__main__': main() The parameter top_block_cls=simple_fm_receiver is your flow graph, which inherits the gr.top_block . The Key Methods of interest here are Start : Start the contained flowgraph. Creates one or more threads to execute the flow graph. Returns to the caller once the threads are created. Stop : Stop the running flowgraph. Notifies each thread created by the scheduler to shutdown, then returns to caller. Wait :Wait for a flowgraph to complete. Flowgraphs complete when either (1) all blocks indicate that they are done, or (2) after stop() has been called to request shutdown. Your application Create a new python virtual environment make sure to include system packages so that your code can find GNU Radio. Note : Make sure to include system packages so that your interpreter can find the GNU Radio library # Create environment python -m venv .venv --system-site-packages # Activate (Linux/Mac) source .venv/bin/activate # Activate (Windows) .venv\\Scripts\\activate Create your application file, app.py and include the following code to start a pyqt5 application with a single button to toggle the flowgraph, make sure that both the flowgraph file and your app is in same directory, or can access one another to import your top block fm receiver. import sys from PyQt5.QtWidgets import QApplication, QPushButton, QWidget, QVBoxLayout # First Import your flowgraph from fm_receiver import fm_receiver class FM(QWidget): def __init__(self): super().__init__() self.setWindowTitle(\"PyQt5 Simple FM Example\") # Instantiate FM Receiver App self.tb = fm_receiver() self.setMinimumSize(700, 500) # State variable self.listening = False # Layout layout = QVBoxLayout() # Button self.button = QPushButton(\"Start Listening\") self.button.clicked.connect(self.toggle_listening) # connect click event layout.addWidget(self.button) self.setLayout(layout) def toggle_listening(self): \"\"\"Toggle listening state and update button text.\"\"\" self.listening = not self.listening if self.listening: self.button.setText(\"Stop Listening\") print(\"Listening started...\") self.tb.start() else: self.button.setText(\"Start Listening\") print(\"Listening stopped.\") self.tb.stop() self.tb.wait() if __name__ == \"__main__\": app = QApplication(sys.argv) window = FM() window.show() sys.exit(app.exec_()) The first step is to import your flowgraph and instantiate it in the init of your application in order to control it from anywhere. from yourdirectory.simple_fm import simple_fm . . . # Instantiate FM Receiver App self.tb = simple_fm() Then the button will toggle the flowgraph allowing the user to stop or continue the flowgraph on command. def toggle_listening(self): \"\"\"Toggle listening state and update button text.\"\"\" self.listening = not self.listening if self.listening: self.button.setText(\"Stop Listening\") print(\"Listening started...\") self.tb.start() else: self.button.setText(\"Start Listening\") print(\"Listening stopped.\") self.tb.stop() self.tb.wait() Run your application Finally, Run your application, and you now have your first python application with GRC backend. This way you can control anything in your flowgraph, from simple setting the center frequency to more advanced usage like disconnected and connecting blocks. Advance Features This section covers more advance controls that can make your python app manage every single detail of your flowgraph. This explanation is specific for the FM Application but can be applied anywhere else. The topics covered in this tutorial are: Variable Control Use GRC GUI elements in your python application Using parameters for your flowgraph Advance control over blocks, by disconnecting and reconnecting blocks Setting Variables If you click the on the listen button there is a big possibility that you'll hear some noise. In order to listen to an actual station you need to be able to tune to a specific center frequency. Looking at the python generated file, you'll find at the very bottom some getters and setters: def set_freq(self, freq): self.freq = freq self.qtgui_freq_sink_x_0.set_frequency_range(self.freq, self.samp_rate) self.qtgui_waterfall_sink_x_0.set_frequency_range(self.freq, self.samp_rate) self.soapy_rtlsdr_source_0.set_frequency(0, self.freq) So in order to set frequency, you need to tie this method to a GUI element in your application. You can get as create as you want with the widget, but for the sake of simplicity lets use QSlider . Add a Slider widget along with a function to handle changing the frequency. # Frequency Label self.freq_label = QLabel(\"Frequency: 100 MHz\") layout.addWidget(self.freq_label) # Frequency Slider self.freq_slider = QSlider(Qt.Horizontal) self.freq_slider.setMinimum(88000000) # 88 MHz self.freq_slider.setMaximum(108000000) # 108 MHz self.freq_slider.setValue(int(self.tb.get_freq())) # Default 100 MHz self.freq_slider.setTickInterval(int(1e6)) # 1 mhz step self.freq_slider.setSingleStep(100000) self.freq_slider.valueChanged.connect(self.change_frequency) layout.addWidget(self.freq_slider) def change_frequency(self, freq): \"\"\"Update FM receiver frequency from slider.\"\"\" self.tb.set_freq(freq) self.freq_label.setText(f\"Frequency: {freq/1e6:.1f} MHz\") print(f\"Frequency set to {freq/1e6:.1f} MHz\") We've used the get_freq() method to set the default value of the slider just as the current frequency of our receiver. And used the set_freq() method to edit the SDRs center frequency and listen t0 multiple stations. Using GUI Blocks To tune into stations, we can look for peaks in the frequency-domain view of our signal. GNU Radio\u2019s QT Frequency Sink makes this easy by showing the signal spectrum in real time. When you generate your flowgraph, check the Python file: GUI elements are added to the QT layout with addWidget(). The variables passed here (usually ending in _win) are the widget objects you can embed directly into your application. self._qtgui_freq_sink_x_0_win = sip.wrapinstance(self.qtgui_freq_sink_x_0.qwidget(), Qt.QWidget) self.top_layout.addWidget(self._qtgui_freq_sink_x_0_win) Disconnecting and Connecting Blocks Suppose you want to record a specific stream only when triggered by a button press. Fortunately, GNU Radio allows you to control your flowgraph programmatically from within your Python application. This means you can dynamically connect and disconnect blocks as needed. In this example, we\u2019ll demonstrate how to connect an audio sink to an FM decoder when the recording action is triggered. You can approach this in two ways: Create the block directly in Python by checking the block\u2019s constructor (from API refernce) and instantiating it in your code. (My Way) Add the block to your GNU Radio flowgraph in the Companion (GRC), then generate the Python code. By reviewing the generated code, you can see exactly how the block is constructed and how the connections are defined. This method makes it easier to understand the correct parameters and wiring before you replicate it programmatically. After Adding the block to the flowgraph, here is the python code for the wave file sink block: from gnuradio import audio . . . self.blocks_wavfile_sink_0 = blocks.wavfile_sink( 'filename', 1, samp_rate, blocks.FORMAT_WAV, blocks.FORMAT_PCM_16, False ) ################################################## # Connections ################################################## self.connect((self.analog_wfm_rcv_0, 0), (self.blocks_wavfile_sink_0, 0)) So lets get back to our application and create a button to trigger recording in a specific file. The first step is to initialize the block: from gnuradio import blocks # Initialize wavfile sink (but don't connect yet) self.recorder = blocks.wavfile_sink( 'recording.wav', # Output file 1, # Number of channels int(48e3), blocks.FORMAT_WAV, blocks.FORMAT_PCM_16, False ) Then add record button # Record button self.recording = False self.record_button = QPushButton(\"Start Recording\") self.record_button.clicked.connect(self.toggle_recording) layout.addWidget(self.record_button) Finaly create a function to toggle recording and stopping: def toggle_recording(self): \"\"\"Toggle audio recording by connecting/disconnecting wavfile_sink.\"\"\" self.recording = not self.recording if self.recording: self.record_button.setText(\"Stop Recording\") print(\"Recording started...\") # Dynamically connect FM decoder to wavfile sink self.tb.stop() self.tb.wait() self.tb.connect((self.tb.analog_wfm_rcv_0, 0), (self.recorder, 0)) self.tb.start() else: self.record_button.setText(\"Start Recording\") print(\"Recording stopped.\") # Disconnect wavfile sink self.tb.stop() self.tb.wait() try: self.tb.disconnect((self.tb.analog_wfm_rcv_0, 0), (self.recorder, 0)) except Exception as e: print(\"Already disconnected:\", e) self.tb.start() The full application code is: import sys from PyQt5.QtWidgets import QApplication, QPushButton, QWidget, QVBoxLayout, QSlider, QLabel from PyQt5.QtCore import Qt # Import your flowgraph from fm_receiver import fm_receiver from gnuradio import audio, blocks class FM(QWidget): def __init__(self): super().__init__() self.setWindowTitle(\"PyQt5 FM Receiver with Recording\") # Instantiate FM Receiver App self.tb = fm_receiver() self.setMinimumSize(700, 500) # State variables self.listening = False self.recording = False # Initialize recording block (not yet connected) self.recorder = blocks.wavfile_sink( 'recording.wav', # Output filename 1, # Number of channels int(48e3), # Sample rate from flowgraph blocks.FORMAT_WAV, blocks.FORMAT_PCM_16, False ) # Layout layout = QVBoxLayout() # Listening Button self.listen_button = QPushButton(\"Start Listening\") self.listen_button.clicked.connect(self.toggle_listening) layout.addWidget(self.listen_button) # Recording Button self.record_button = QPushButton(\"Start Recording\") self.record_button.clicked.connect(self.toggle_recording) layout.addWidget(self.record_button) # Frequency Label self.freq_label = QLabel(\"Frequency: 100 MHz\") layout.addWidget(self.freq_label) # Frequency Slider self.freq_slider = QSlider(Qt.Horizontal) self.freq_slider.setMinimum(88000000) # 88 MHz self.freq_slider.setMaximum(108000000) # 108 MHz self.freq_slider.setValue(int(self.tb.get_freq())) # Default 100 MHz self.freq_slider.setTickInterval(int(1e6)) # 1 MHz step self.freq_slider.setSingleStep(100000) self.freq_slider.valueChanged.connect(self.change_frequency) layout.addWidget(self.freq_slider) # Add the Frequency Sink widget from GNU Radio (Qt GUI block) layout.addWidget(self.tb._qtgui_freq_sink_x_0_win) self.setLayout(layout) def toggle_listening(self): \"\"\"Toggle listening state and update button text.\"\"\" self.listening = not self.listening if self.listening: self.listen_button.setText(\"Stop Listening\") print(\"Listening started...\") self.tb.start() else: self.listen_button.setText(\"Start Listening\") print(\"Listening stopped.\") self.tb.stop() self.tb.wait() def toggle_recording(self): \"\"\"Toggle audio recording by connecting/disconnecting wavfile_sink.\"\"\" self.recording = not self.recording if self.recording: self.record_button.setText(\"Stop Recording\") print(\"Recording started...\") # Dynamically connect FM decoder to wavfile sink self.tb.stop() self.tb.wait() self.tb.connect((self.tb.analog_wfm_rcv_0, 0), (self.recorder, 0)) self.tb.start() else: self.record_button.setText(\"Start Recording\") print(\"Recording stopped.\") # Disconnect wavfile sink self.tb.stop() self.tb.wait() try: self.tb.disconnect((self.tb.analog_wfm_rcv_0, 0), (self.recorder, 0)) except Exception as e: print(\"Already disconnected:\", e) self.tb.start() def change_frequency(self, freq): \"\"\"Update FM receiver frequency from slider.\"\"\" self.tb.set_freq(freq) self.freq_label.setText(f\"Frequency: {freq/1e6:.1f} MHz\") print(f\"Frequency set to {freq/1e6:.1f} MHz\") if __name__ == \"__main__\": app = QApplication(sys.argv) window = FM() window.show() sys.exit(app.exec_())","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"This comprehensive guide demonstrates how to integrate GNU Radio flowgraphs into custom Python GUI applications, giving you full programmatic control over signal processing workflows. GNU Radio uses a concept called \"flowgraphs\" - visual representations of signal processing chains where blocks (filters, modulators, sources, sinks) are connected together. When you create a flowgraph in GNU Radio Companion (GRC), it generates Python code that can be integrated into your applications.","title":"Tutorials"},{"location":"tutorials/#integrating-gnu-radio-to-you-python-app","text":"","title":"Integrating GNU Radio to you Python App"},{"location":"tutorials/#create-your-flow-graph","text":"Start by building a simple FM receiver flow graph following this tutorial RTL-SDR FM Receiver tutorial . Alternatively you can download the GRC file directly from wget https://raw.githubusercontent.com/StudHamza/GNU-Radio-FM-App/main/src/fm_receiver/flowgraphs/fm_receiver.grc Run the file using GNU Radio Companion, and open the generated python file.","title":"Create Your Flow graph"},{"location":"tutorials/#understanding-the-generated-code","text":"When you generate Python code from GRC, you get a class structure like this: class simple_fm_receiver(gr.top_block, Qt.QWidget): def __init__(self): gr.top_block.__init__(self, \"Simple FM Receiver\") Qt.QWidget.__init__(self) # Variables (can be modified at runtime) self.freq = freq = 101.1e6 # Center frequency self.samp_rate = samp_rate = 2048000 # Sample rate # Blocks self.rtlsdr_source = osmosdr.source(args=\"numchan=1\") self.low_pass_filter = filter.fir_filter_ccf(...) self.analog_wfm_rcv = analog.wfm_rcv(...) self.audio_sink = audio.sink(48000) # Connections self.connect((self.rtlsdr_source, 0), (self.low_pass_filter, 0)) # ... more connections def closeEvent(self, event): self.settings = Qt.QSettings(\"GNU Radio\", \"fm_receiver\") self.settings.setValue(\"geometry\", self.saveGeometry()) self.stop() self.wait() event.accept() # Getters and Setters def get_samp_rate(self): return self.samp_rate def set_samp_rate(self, samp_rate): self.samp_rate = samp_rate def get_freq(self): return self.freq def set_freq(self, freq): self.freq = freq self.qtgui_sink_x_0.set_frequency_range(self.freq, 2.048e6) self.soapy_rtlsdr_source_0.set_frequency(0, self.freq) def get_fft_size(self): return self.fft_size def set_fft_size(self, fft_size): self.fft_size = fft_size Look for the main function at the very end of the file. def main(top_block_cls=simple_fm_receiver, options=None): tb = top_block_cls() def sig_handler(sig=None, frame=None): tb.stop() tb.wait() sys.exit(0) signal.signal(signal.SIGINT, sig_handler) signal.signal(signal.SIGTERM, sig_handler) tb.start() try: input('Press Enter to quit: ') except EOFError: pass tb.stop() tb.wait() if __name__ == '__main__': main() The parameter top_block_cls=simple_fm_receiver is your flow graph, which inherits the gr.top_block . The Key Methods of interest here are Start : Start the contained flowgraph. Creates one or more threads to execute the flow graph. Returns to the caller once the threads are created. Stop : Stop the running flowgraph. Notifies each thread created by the scheduler to shutdown, then returns to caller. Wait :Wait for a flowgraph to complete. Flowgraphs complete when either (1) all blocks indicate that they are done, or (2) after stop() has been called to request shutdown.","title":"Understanding the Generated Code"},{"location":"tutorials/#your-application","text":"Create a new python virtual environment make sure to include system packages so that your code can find GNU Radio. Note : Make sure to include system packages so that your interpreter can find the GNU Radio library # Create environment python -m venv .venv --system-site-packages # Activate (Linux/Mac) source .venv/bin/activate # Activate (Windows) .venv\\Scripts\\activate Create your application file, app.py and include the following code to start a pyqt5 application with a single button to toggle the flowgraph, make sure that both the flowgraph file and your app is in same directory, or can access one another to import your top block fm receiver. import sys from PyQt5.QtWidgets import QApplication, QPushButton, QWidget, QVBoxLayout # First Import your flowgraph from fm_receiver import fm_receiver class FM(QWidget): def __init__(self): super().__init__() self.setWindowTitle(\"PyQt5 Simple FM Example\") # Instantiate FM Receiver App self.tb = fm_receiver() self.setMinimumSize(700, 500) # State variable self.listening = False # Layout layout = QVBoxLayout() # Button self.button = QPushButton(\"Start Listening\") self.button.clicked.connect(self.toggle_listening) # connect click event layout.addWidget(self.button) self.setLayout(layout) def toggle_listening(self): \"\"\"Toggle listening state and update button text.\"\"\" self.listening = not self.listening if self.listening: self.button.setText(\"Stop Listening\") print(\"Listening started...\") self.tb.start() else: self.button.setText(\"Start Listening\") print(\"Listening stopped.\") self.tb.stop() self.tb.wait() if __name__ == \"__main__\": app = QApplication(sys.argv) window = FM() window.show() sys.exit(app.exec_()) The first step is to import your flowgraph and instantiate it in the init of your application in order to control it from anywhere. from yourdirectory.simple_fm import simple_fm . . . # Instantiate FM Receiver App self.tb = simple_fm() Then the button will toggle the flowgraph allowing the user to stop or continue the flowgraph on command. def toggle_listening(self): \"\"\"Toggle listening state and update button text.\"\"\" self.listening = not self.listening if self.listening: self.button.setText(\"Stop Listening\") print(\"Listening started...\") self.tb.start() else: self.button.setText(\"Start Listening\") print(\"Listening stopped.\") self.tb.stop() self.tb.wait()","title":"Your application"},{"location":"tutorials/#run-your-application","text":"Finally, Run your application, and you now have your first python application with GRC backend. This way you can control anything in your flowgraph, from simple setting the center frequency to more advanced usage like disconnected and connecting blocks.","title":"Run your application"},{"location":"tutorials/#advance-features","text":"This section covers more advance controls that can make your python app manage every single detail of your flowgraph. This explanation is specific for the FM Application but can be applied anywhere else. The topics covered in this tutorial are: Variable Control Use GRC GUI elements in your python application Using parameters for your flowgraph Advance control over blocks, by disconnecting and reconnecting blocks","title":"Advance Features"},{"location":"tutorials/#setting-variables","text":"If you click the on the listen button there is a big possibility that you'll hear some noise. In order to listen to an actual station you need to be able to tune to a specific center frequency. Looking at the python generated file, you'll find at the very bottom some getters and setters: def set_freq(self, freq): self.freq = freq self.qtgui_freq_sink_x_0.set_frequency_range(self.freq, self.samp_rate) self.qtgui_waterfall_sink_x_0.set_frequency_range(self.freq, self.samp_rate) self.soapy_rtlsdr_source_0.set_frequency(0, self.freq) So in order to set frequency, you need to tie this method to a GUI element in your application. You can get as create as you want with the widget, but for the sake of simplicity lets use QSlider . Add a Slider widget along with a function to handle changing the frequency. # Frequency Label self.freq_label = QLabel(\"Frequency: 100 MHz\") layout.addWidget(self.freq_label) # Frequency Slider self.freq_slider = QSlider(Qt.Horizontal) self.freq_slider.setMinimum(88000000) # 88 MHz self.freq_slider.setMaximum(108000000) # 108 MHz self.freq_slider.setValue(int(self.tb.get_freq())) # Default 100 MHz self.freq_slider.setTickInterval(int(1e6)) # 1 mhz step self.freq_slider.setSingleStep(100000) self.freq_slider.valueChanged.connect(self.change_frequency) layout.addWidget(self.freq_slider) def change_frequency(self, freq): \"\"\"Update FM receiver frequency from slider.\"\"\" self.tb.set_freq(freq) self.freq_label.setText(f\"Frequency: {freq/1e6:.1f} MHz\") print(f\"Frequency set to {freq/1e6:.1f} MHz\") We've used the get_freq() method to set the default value of the slider just as the current frequency of our receiver. And used the set_freq() method to edit the SDRs center frequency and listen t0 multiple stations.","title":"Setting Variables"},{"location":"tutorials/#using-gui-blocks","text":"To tune into stations, we can look for peaks in the frequency-domain view of our signal. GNU Radio\u2019s QT Frequency Sink makes this easy by showing the signal spectrum in real time. When you generate your flowgraph, check the Python file: GUI elements are added to the QT layout with addWidget(). The variables passed here (usually ending in _win) are the widget objects you can embed directly into your application. self._qtgui_freq_sink_x_0_win = sip.wrapinstance(self.qtgui_freq_sink_x_0.qwidget(), Qt.QWidget) self.top_layout.addWidget(self._qtgui_freq_sink_x_0_win)","title":"Using GUI Blocks"},{"location":"tutorials/#disconnecting-and-connecting-blocks","text":"Suppose you want to record a specific stream only when triggered by a button press. Fortunately, GNU Radio allows you to control your flowgraph programmatically from within your Python application. This means you can dynamically connect and disconnect blocks as needed. In this example, we\u2019ll demonstrate how to connect an audio sink to an FM decoder when the recording action is triggered. You can approach this in two ways: Create the block directly in Python by checking the block\u2019s constructor (from API refernce) and instantiating it in your code. (My Way) Add the block to your GNU Radio flowgraph in the Companion (GRC), then generate the Python code. By reviewing the generated code, you can see exactly how the block is constructed and how the connections are defined. This method makes it easier to understand the correct parameters and wiring before you replicate it programmatically. After Adding the block to the flowgraph, here is the python code for the wave file sink block: from gnuradio import audio . . . self.blocks_wavfile_sink_0 = blocks.wavfile_sink( 'filename', 1, samp_rate, blocks.FORMAT_WAV, blocks.FORMAT_PCM_16, False ) ################################################## # Connections ################################################## self.connect((self.analog_wfm_rcv_0, 0), (self.blocks_wavfile_sink_0, 0)) So lets get back to our application and create a button to trigger recording in a specific file. The first step is to initialize the block: from gnuradio import blocks # Initialize wavfile sink (but don't connect yet) self.recorder = blocks.wavfile_sink( 'recording.wav', # Output file 1, # Number of channels int(48e3), blocks.FORMAT_WAV, blocks.FORMAT_PCM_16, False ) Then add record button # Record button self.recording = False self.record_button = QPushButton(\"Start Recording\") self.record_button.clicked.connect(self.toggle_recording) layout.addWidget(self.record_button) Finaly create a function to toggle recording and stopping: def toggle_recording(self): \"\"\"Toggle audio recording by connecting/disconnecting wavfile_sink.\"\"\" self.recording = not self.recording if self.recording: self.record_button.setText(\"Stop Recording\") print(\"Recording started...\") # Dynamically connect FM decoder to wavfile sink self.tb.stop() self.tb.wait() self.tb.connect((self.tb.analog_wfm_rcv_0, 0), (self.recorder, 0)) self.tb.start() else: self.record_button.setText(\"Start Recording\") print(\"Recording stopped.\") # Disconnect wavfile sink self.tb.stop() self.tb.wait() try: self.tb.disconnect((self.tb.analog_wfm_rcv_0, 0), (self.recorder, 0)) except Exception as e: print(\"Already disconnected:\", e) self.tb.start() The full application code is: import sys from PyQt5.QtWidgets import QApplication, QPushButton, QWidget, QVBoxLayout, QSlider, QLabel from PyQt5.QtCore import Qt # Import your flowgraph from fm_receiver import fm_receiver from gnuradio import audio, blocks class FM(QWidget): def __init__(self): super().__init__() self.setWindowTitle(\"PyQt5 FM Receiver with Recording\") # Instantiate FM Receiver App self.tb = fm_receiver() self.setMinimumSize(700, 500) # State variables self.listening = False self.recording = False # Initialize recording block (not yet connected) self.recorder = blocks.wavfile_sink( 'recording.wav', # Output filename 1, # Number of channels int(48e3), # Sample rate from flowgraph blocks.FORMAT_WAV, blocks.FORMAT_PCM_16, False ) # Layout layout = QVBoxLayout() # Listening Button self.listen_button = QPushButton(\"Start Listening\") self.listen_button.clicked.connect(self.toggle_listening) layout.addWidget(self.listen_button) # Recording Button self.record_button = QPushButton(\"Start Recording\") self.record_button.clicked.connect(self.toggle_recording) layout.addWidget(self.record_button) # Frequency Label self.freq_label = QLabel(\"Frequency: 100 MHz\") layout.addWidget(self.freq_label) # Frequency Slider self.freq_slider = QSlider(Qt.Horizontal) self.freq_slider.setMinimum(88000000) # 88 MHz self.freq_slider.setMaximum(108000000) # 108 MHz self.freq_slider.setValue(int(self.tb.get_freq())) # Default 100 MHz self.freq_slider.setTickInterval(int(1e6)) # 1 MHz step self.freq_slider.setSingleStep(100000) self.freq_slider.valueChanged.connect(self.change_frequency) layout.addWidget(self.freq_slider) # Add the Frequency Sink widget from GNU Radio (Qt GUI block) layout.addWidget(self.tb._qtgui_freq_sink_x_0_win) self.setLayout(layout) def toggle_listening(self): \"\"\"Toggle listening state and update button text.\"\"\" self.listening = not self.listening if self.listening: self.listen_button.setText(\"Stop Listening\") print(\"Listening started...\") self.tb.start() else: self.listen_button.setText(\"Start Listening\") print(\"Listening stopped.\") self.tb.stop() self.tb.wait() def toggle_recording(self): \"\"\"Toggle audio recording by connecting/disconnecting wavfile_sink.\"\"\" self.recording = not self.recording if self.recording: self.record_button.setText(\"Stop Recording\") print(\"Recording started...\") # Dynamically connect FM decoder to wavfile sink self.tb.stop() self.tb.wait() self.tb.connect((self.tb.analog_wfm_rcv_0, 0), (self.recorder, 0)) self.tb.start() else: self.record_button.setText(\"Start Recording\") print(\"Recording stopped.\") # Disconnect wavfile sink self.tb.stop() self.tb.wait() try: self.tb.disconnect((self.tb.analog_wfm_rcv_0, 0), (self.recorder, 0)) except Exception as e: print(\"Already disconnected:\", e) self.tb.start() def change_frequency(self, freq): \"\"\"Update FM receiver frequency from slider.\"\"\" self.tb.set_freq(freq) self.freq_label.setText(f\"Frequency: {freq/1e6:.1f} MHz\") print(f\"Frequency set to {freq/1e6:.1f} MHz\") if __name__ == \"__main__\": app = QApplication(sys.argv) window = FM() window.show() sys.exit(app.exec_())","title":"Disconnecting and Connecting Blocks"},{"location":"functions/","text":"","title":"Index"}]}